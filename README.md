## 开源10年 
 项目首发于 **计算机自学平台** 公众号
---
### 关于作者
一个深漂近10年的菜鸟程序员,我愿意分享关于这10年来程序人生中的点点滴滴，若添加好友请备注：**开源10年**
![WechatIMG268.jpeg](https://s2.loli.net/2022/03/22/6SmsB8vZhq2irXR.jpg)

### 关于项目介绍
这个项目是我打算用10年时间来操作维护的一个项目，从微小处入手，一步一步搭建一个大型综合系统，并且我会自己购买服务器和域名让他正常运行起来。其次我会把本项目中所有遇到的知识点都一一罗列出来并进行详解，一是为了让自己印象加深，二是让更多的程序员可以从中获取到点什么。

#### 目录

- 2022-3-28 blog注册登录及验证权限实战之jwt-go的运用 [跳转](#8)
- 开源一周总结（无代码纯日记） [跳转](#7)
- 2022-3-24 Go项目中的最友好的数据库中间件GORM详解 [跳转](#6)
- 2022-3-22 Go项目配置管理力荐Viper之Viper详解篇 [跳转](#5)
- 2022-3-20 Go语言下的Gin详解及Demo实践 [跳转](#4)
- 2022-3-19 Blog项目骨架搭建---Go语言 [跳转](#3)
- 2022-3-18 项目准备工作 [跳转](#2)
- 2022-3-17 《开源十年》项目源自于脑海中的一个想法  [跳转](#1)



###  <a id="jump">《开源十年》项目源自于脑海中的一个想法</a>

​	2022年开年到今天已经过去三个半月了，在今年开始的第一天我看了老罗的《时间的朋友》直播，也购买了大佬的《变量4》。

​	在看这本书的时候，我心里面越看越烦躁，我的烦躁和这本书的内容无关。烦躁的是自己的懦弱和懒惰。何帆老师发愿要用30年的时间为中国的经济立传，至于书的内容怎么样我不做评判，但这种决心让我脸颊发红。

​	毕业至今多少年了，每年伊始都给自己立下各种flag，年底回头一看完成的寥寥无几。每次这个时候都会自己给自己找借口：

​	今年忙。。。

​	今年干那啥事耽误了时间。。。

​	看看身边其他人，自己今年好像也小有成就，flag不flag的随他去吧。。。

​	前年在公司的要求下读了王阳明，去年自发的看了曾国藩。每次在读他们故事的时候就发愿要学做他们这样的圣人，可书放下不久这个愿就随风而逝。

​	每一年好像除了工作和生活，自己从来没有永恒的坚持去做意见有意义的事情。平时不经意间脑海总是会蹦出各种各样的想法，但是后面又都不了了之。

​	前不久在知乎上看到一个问答，说你每天那么拼命的工作赚钱到底是为了什么？下面有人说为了让自己的后代能实现阶层的跨越，当时看到这句话我颇为赞成。但是在这个回答的下面有一个回复，说三代以后你的子孙可能都已经记不住你的名字了。这句话让我陷入了深深的沉思，那我存在的意义到底是什么？我拼搏的意义是什么？

​	日复一日，年复一年。随着年龄的增长，岁月的侵蚀，来自心底的空虚、孤独和焦虑让我不堪其烦。我寻找了很久，这些来自心底的负面情绪到底是怎么出现的？今天在居家办公的第3天，我突然明悟了。原来他们来自我内心的自卑和懒惰，来自我逃避生活的懦弱和懒惰，来自我盲目的自信和浮躁的人品。很多时候我都特别享受来自别人的夸奖和羡慕，殊不知自己这种市井小民的虚荣是多么的可笑和无知。

​	何帆老师要坚持30年写《变量》，那他的目的是什么？为了赚钱么？也许是，但我不这么认为，我觉得他是在记录历史并分享给读者，把每一处节点发生的事情串联起来，让大家更好的了解这段历史并可以从中发现些什么，让读者能更好的理解这段历史的意义从而清晰自己将走的路该怎么规划。

​	所以，我要向何帆老师学习，他用他的方式记录历史并分享给大家。那我就用一段一段的代码讲述程序员存在的意义，让每一位程序员或者想进入这个行业从业的人员能更好的了解每一段代码，并用它来实现自己想要的价值提现。

​	不论未来有多少艰险和困难，我相信我都可以一一克服。从网站的搭建、备案到内容的整理和编辑，一步一个脚印，只希望我把我已走过的路清晰的呈现在读者面前，让每一位读者能从中得到点什么并使读者可以清晰的明白自己未来的路到底该怎么走。

​	我在这本日记的扉页写下“开源十年”，我希望在我未来的这十年能坚持下去，并矢志不渝的保持住这个初心。

​	开源十年这个项目，我将以初学者的态度去做，怎么设计？怎么编程？遇到不会的怎么学习？遇到难题怎么解决？怎么开发？怎么部署？怎么优化？让每一位读者不管是什么级别的程序员都能一眼看懂并理解。此项目纯属实战项目，只需要有编程语言的基础即可。

​	下一步的规划：

​	1、规划项目的功能并拆分为开发需求

​	2、开始编程并在github中开源

​	3、购买服务器部署并备案供每一位读者参阅





## <a id="2">项目启动---先做个BLOG用</a>



昨天迸发了这个想法之后就立刻记录下来并通过**计算机自学平台**这个公众号投了出去，因为目前对我来说最大的阻碍不是技术问题OR精力投入问题，而是能不能坚持下去的问题。

以前也立过很多flag，最后都没有坚持下去。比如：我记单词用的百词斩，每天坚持打卡50个单词，但是在我坚持了173天的时候就断掉了。今天我还认真的去分析了断掉的原因。就是没有形成自我督促，因为断不断都是我自己的事，别人也不知道你坚持了多久，断就断了感觉也无所谓。所以这次我没给自己留一点后路。既然要坚持就逼自己一把，直接投出去把自己在这个圈子的脸面赌出去。如果后面坚持不下去了，也就别打算继续在这个圈子混了。

今天主要做的就是一些准备工作，首先是语言的选择上。后端编程我打算使用Golang，之所以不选择自己最熟悉的JAVA就是因为前面我说过的那句话，我要以初学者的心态去做这个项目。Golang对于我来说虽然不陌生，但毕竟没有正式去承接过大型项目。前端打算选VUE，同理选它是因为我没用过。所以在后面的项目中如果哪位大佬发现我的写法或者用法不对请直接指出。

下面简单说说这个项目吧，昨天只是提出了项目的目的，没有详细说项目的实际内容。其实我也不知道这个项目都有哪些东西，所以我在前面说过，有什么东西大家说了算。我也是想到哪里就写到哪里。总之一个原则，把所有能想到的用法都用代码去实现一遍并寻找更优的解决方案，然后开源供大家参考。

比如说分布式存储，每一步是怎么做的，是怎么实现的海量文件存储的，如何快速访问所存文件，代码怎么编写的等等，我们共同一步一步去实现它。或者更简单点的就是一个注册登录模块是怎么实现的，为了满足各种需求我们还可以怎么扩展等等。由简入繁再拆分细化去实现它。

下面就是开发前的一些准备，

1）下载安装并激活Goland

2）安装MySQL

3）梳理下一阶段的需求

4）设计当前阶段数据库表结构

这一个阶段的工作是实现一个简单的博客功能，后台可以注册登录并编辑文章，前端用来展示文章列表和文章内容。

这个阶段之所以选择实现这么一个功能是因为我想先做个《开源十年》的网站出来，以后这个项目的更新都搬过去，一个真正的从零开始的并正常运行的项目更有说服力。这样一来面向的受众会更多更广泛且不给自己的懒惰留一丁点的退路。

**下面是本阶段的思维导图：**



![img](https://pic3.zhimg.com/80/v2-4a3e0b9b95be4d0c77031e293da53dfa_720w.jpg)



**前端展示分两部分**

1）Web端页面展示

2）H5手机端页面展示

**后端两个模块**

1）账号管理模块

2）文章管理模块（增删查改）

**文章相关数据字段**

标题、内容、作者、创建时间、更新时间

**账号相关数据**

账号、密码、手机号、昵称、创建时间

**目前库表设计**



![img](https://pic1.zhimg.com/80/v2-70616294679c46fca081420f67eeaaa0_720w.jpg)



**功能API设计**

账号注册 v1/account/register

账号登录 v1/account/login

密码修改 v1/account/update

文章列表 v1/blog/list

文章详情 v1/blog/detail

创建文章 v1/blog/create

修改文章 v1/blog/update

一个简单的博客基础骨架就出来了，下一步就是代码的编写了。目前想到的就这些，没有必要在这个阶段纠结太多，项目中很多问题都是在开发过程中发现的，到时候再去一一应对。如果在这个阶段浪费太多时间，就会导致整个项目的难以推进。

好了，暂时更新这么多吧，祝各位晚安！





## <a id="3">Blog项目骨架搭建---Go语言（第一阶段）</a>

今天周六，利用两个多小时的时间把昨天的需求简单梳理了一下，并开始搭建项目，进行了简单的编辑，到目前为止已经实现注册功能了。

这个项目到今天是第三天了，我并不能保证每天都更新日记，但确实每天都会更新项目，时间多久多做点，时间少就少做点，总之这个事情是不可以断的。希望各位也给我助助威，鞭策一下我这颗懒惰的心。

本节主要涉及以下几个知识点：

1）gin web框架

2）viper 配置管理

3）Gorm 数据库连接

这三个知识点我后面单独拉出来介绍，这节仅简单介绍并陈述我都做了什么。

**一、选择Gin框架**

在 Go语言开发的 Web 框架中，有两款著名 Web 框架分别是 Martini 和 Gin，两款 Web 框架相比较的话，Gin 自己说它比 Martini 要强很多。

Gin 是 Go语言写的一个 web 框架，它具有运行速度快，分组的路由器，良好的崩溃捕获和错误处理，非常好的支持中间件和 json。总之在 Go语言开发领域是一款值得好好研究的 Web 框架

gin安装：go get -u [http://github.com/gin-gonic/gin](https://link.zhihu.com/?target=http%3A//github.com/gin-gonic/gin)

本项目中初始化位置：

![img](https://pic4.zhimg.com/80/v2-55427a3d55a310224ef9b225e8e19b33_720w.jpg)

**二、选自viper做配置管理**

viper 是一个配置解决方案，拥有丰富的特性：

- 支持 JSON/TOML/YAML/HCL/envfile/Java properties 等多种格式的配置文件；
- 可以设置监听配置文件的修改，修改时自动加载新的配置；
- 从环境变量、命令行选项和io.Reader中读取配置；
- 从远程配置系统中读取和监听修改，如 etcd/Consul；
- 代码逻辑中显示设置键值。

Viper安装：go get [http://github.com/spf13/viper](https://link.zhihu.com/?target=http%3A//github.com/spf13/viper)

本项目中初始化位置：

![img](https://pic1.zhimg.com/80/v2-69a3df27012e7d4a8c9d86fe13462e4c_720w.jpg)

![img](https://pic4.zhimg.com/80/v2-37fdd5d36f58bd4bd6834e5d55718e5b_720w.jpg)

根据以上代码可知，我的配置文件放下项目路径/config下，文件为：application.yml。

**三、数据库连接使用Gorm库**

gorm是go语言的一个orm框架,具体的原理及思想我也介绍不清楚，你只需要知道它是你操作数据库的桥梁即可、

Gorm安装：go get -u [http://github.com/jinzhu/gorm](https://link.zhihu.com/?target=http%3A//github.com/jinzhu/gorm)

本项目中初始化位置：

![img](https://pic2.zhimg.com/80/v2-9d5fcd6309a98e28275899295092fd5d_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-7b48b6ed55166ffcfe9c3f16dd1105ed_720w.jpg)

上图中的viper.GetString("datasource.driverName")就是利用前面说过的配置管理viper去配置文件中获取相对应的参数。

具体的配置文件如下：

![img](https://pic1.zhimg.com/80/v2-86b3083dfe913f9c73df4547c613a7c4_720w.jpg)

这里留一个小彩蛋，只有在真正运行项目的时候才会发现哦

**四、创建数据模型**

一共创建了两个数据模型

![img](https://pic2.zhimg.com/80/v2-d08876977c311cd726cefe9d24d12225_720w.jpg)

![img](https://pic2.zhimg.com/80/v2-e4749fcf00652bd4579e6b38213a3fb9_720w.jpg)

这里一共设计到三个知识点

1）gorm.Model这个标记一个结构中有一个结构中没有，那他是用来干什么的呢？其实这就相当于是继承，加上这个后就相当于继承了Model，不加这个代表不继承Model。而Model结构中有以下四个定义好的字段：

![img](https://pic2.zhimg.com/80/v2-5a22f68ffcd8adf236cffa6de1e82ce9_720w.jpg)

这是Gorm自带的，所以你清楚这一点就行了。

2）上面Article结构体中有一个uuid.UUID标记，这个是哪里来的？其实是引用自：

uuid"[http://github.com/satori/go.uuid](https://link.zhihu.com/?target=http%3A//github.com/satori/go.uuid)"

它的主要功能就是在实际项目中，经常会使用到一个唯一标识的，比如唯一标识一条记录等情况，这个go.uuid项目库就是干这个事情的。

3）在上面Article结构体中还有一个非自带类型：Time，这个是自定义的，其作用就是把时间格式化了而已。如果不格式化的话，它显示的就是时间戳，这个大家应该都知道吧？所以它就是让我们能更方便的查看时间。

**五、写了一个接口**

账号注册 v1/account/register

![img](https://pic1.zhimg.com/80/v2-ce76f08369772220496c42bbdc9b59a4_720w.jpg)

这节就先开这一个接口吧，点到为止。贪多贪快嚼不烂，我们的目的是掌握开发过程中出现的各个知识点，并不是完成功能的开发。所以大家不要慌尽量把这节的内容摸透咽下去再进行下一步的开发。

下一节安排：

1、Go 项目实战 之 Gin框架的详解

2、Go 项目实战 之 配件管理viper 详解

3、Go 项目实战 之 数据库连接Grom详解

这个项目到目前为止，基本上骨架就出来了，当然项目本身问题还是很多的，我们会在后面一步一步去完善，为的就是在完善中学习。直接一步到位的框架设计只会在外包项目中出现，我们又不赶进度，慢慢来哈。





## <a id="4">Go语言下的Gin详解及Demo实践</a>

今天没有去继续更新开源10年的项目，因为昨天接触到几个新的知识点，所以今天加强一下对他们的认识，下面是本节的一个知识点。

1）Gin Web框架的认识

2）Gin加载静态资源

3）Gin加载动态资源

在学习Gin的过程中动手搞了一个小Demo，把Gin的简单用发都跑了一下，强烈建议各位读者不要只看文章，自己动手写一下效果更佳。

项目在GitHub上的地址：[https://github.com/kaiyuan10nian/GinDemo](https://link.zhihu.com/?target=https%3A//github.com/kaiyuan10nian/GinDemo)



下面开始我们今天的知识点分享。

一、创建一个Go web项目，这里我命名为：GinDemo，方便我们的学习。

项目结构

![img](https://pic4.zhimg.com/80/v2-e348197212d67e1a12cb7e024000d053_720w.jpg)

Gin安装：go get -u [http://github.com/gin-gonic/gin](https://link.zhihu.com/?target=http%3A//github.com/gin-gonic/gin)

直接在Goland下面的Terminal中输入就可以了。看到下图就表示你安装成功了

![img](https://pic4.zhimg.com/80/v2-1424c34bf85b347ed21d21e8f93a572b_720w.jpg)

二、先写一个小案例，并在Postman或者浏览器中打开看下效果。

在GinDemo下面创建一个main.go文件，输入以下内容：

![img](https://pic2.zhimg.com/80/v2-da8f3583ed46a2b7301de6cd7279c471_720w.jpg)

然后在下面的Termonal中输入以下指令运行该项目：

Go run main.go

看到下图即表示你已经运行起来了。

![img](https://pic3.zhimg.com/80/v2-8ce43416c230aa18159f8a8059cfc3b6_720w.jpg)

这个时候，打开你的浏览器，输入：localhost:8080/ping,将显示以下内容：

![img](https://pic4.zhimg.com/80/v2-faefae54729a836ba403d187b8ff2c7b_720w.jpg)

整个Demo中的注释还是比较清楚的，每一行代码是什么意思，有什么作用等都比较简单，运行到这里基本上Gin的精髓就已经学到了。

下面两个知识点是可以解决我们在真正的实际项目中经常会遇到的需求的。所以我这里单独拉了出来写一下。当然，它还有其它别的更多用法，我们就不一一说了，至少掌握了这两个对于普通的开发工作就足以应对了。

三、加载静态资源

在实际项目中我们经常会用到很多静态资源，比如：图片、文件等。那Gin是怎么处理的呢？还是看案例，下面我们对上面的main.go进行一下简单修改：

![img](https://pic2.zhimg.com/80/v2-33dc491bd60886def79d33e3d2b6e1e1_720w.jpg)

主要加了两行代码，用到两个函数。注释中已经描述的很清楚了，说一下代码中未描述的内容，非常重要，这两个函数的第一个参数就是相对地址，也就是说是用户端访问的时候访问的地址，第二个参数是本地服务器的地址，也就是引用的地址。

比如我们运行上面项目后，若想访问/Users/fu/GolandProjects/GinDemo/web/static里面的图片，那么直接如下操作即可：

![img](https://pic3.zhimg.com/80/v2-6ddc155caafbdca35df8f7bd6462938e_720w.jpg)

若想加载第二种加载形式的，则直接这么访问：

![img](https://pic1.zhimg.com/80/v2-ee6f5f357df3e6e5828b2276d705db3c_720w.jpg)

其实，这两种访问形式访问的都是同一张图片。

这就是静态加载资源的方式方法，那么我们做一个web站点肯定不是仅仅有静态资源，肯定还有动态资源，动态资源的加载怎么实现？

四、加载动态资源

首先，在GinDemo-web下新建templete并在其中新增一个index.html文件，文件内容很简单，这里制作演示所以就没有去做接口互动。

![img](https://pic4.zhimg.com/80/v2-8c450de1340e43c72fc1c9cf84dfd963_720w.jpg)

然后，在根目录下创建了controller文件夹并创建con.go，主要用来存放逻辑层的操作，受JAVA开发的影响我这么去做了，你可以随意哈，怎么高兴怎么来。

![img](https://pic2.zhimg.com/80/v2-69c4988cfa34759d472d8a883f0f7b79_720w.jpg)

还是在main.go中做修改,并加载trmplete下面的资源，然后做了一个web分组，分组中仅有一个接口，其处理放到了con.go文件中的IndexController函数中。

![img](https://pic3.zhimg.com/80/v2-fb6809244ff085d3c8cb2ca599f35fda_720w.jpg)

直接运行，然后浏览器中访问index.html看看有什么效果？

![img](https://pic1.zhimg.com/80/v2-93e4ebd52e4940966c9b330d2e3f0570_720w.jpg)

到这里，其实这个项目就算完成了，其中涉及到的知识点我们也都了解了，就这些内容已经完全够现阶段的我们使用了。

拜拜。。。See you next.





## <a id="5">Go项目配置力荐Viper之Viper详解篇</a>

引言：今天还是补充上次我们搭建项目是遇到的知识点Viper，以下内容了解后基本上在使用Viper上已经无压力了，后面进阶的时候我再补充Viper的进阶篇。

---



Viper 是一个完整的 Go 应用程序配置解决方案，优势就在于开发项目中你不必去操心配置文件的格式而是让你腾出手来专注于项目的开发。其特性如下：

- 支持 JSON/TOML/YAML/HCL/envfile/Java properties 等多种格式的配置文件；
- 可以设置监听配置文件的修改，修改时自动加载新的配置；
- 从环境变量、命令行选项和io.Reader中读取配置；
- 从远程配置系统中读取和监听修改，如 etcd/Consul；
- 代码逻辑中显示设置键值

**注：Viper让需要重启服务器才能使配置生效的日子一去不复返！！！**这才是VIper最大的魅力

#### 基础配置

Viper没有默认的基础配置，所以在使用的过程中我们初始化Viper实例的时候需要告诉Viper你的配置路径、配置格式、配置名称等等信息。Viper虽然支持多配置同时使用，但是一个Viper实例只能寻一个配置路径。

示例：

```Go
viper.SetConfigName("config") // 配置文件名 (不带扩展格式)
viper.SetConfigType("yaml") // 如果你的配置文件没有写扩展名，那么这里需要声明你的配置文件属于什么格式
viper.AddConfigPath("/etc/appname/")   // 配置文件的路径

err := viper.ReadInConfig() //找到并读取配置文件
if err != nil { // 捕获读取中遇到的error
	panic(fmt.Errorf("Fatal error config file: %w \n", err))
}
```

如果在项目中你的配置文件找不到或者找的过程中出error了，怎么办？可以参考下面这么做：

```go
if err := viper.ReadInConfig(); err != nil {
	if _, ok := err.(viper.ConfigFileNotFoundError); ok {
		// 配置文件没有找到，Todo
	} else {
		// 配置文件找到了，但是在这个过程有又出现别的什么error,Todo
	}
}

// 配置文件成功找到，并未再出现什么error则继续往下面执行
```

#### 写入运行时配置

很多时候我们需要记录程序在运行时的一些配置参数，那么Viper也是可以做到的，在Viper中提供了四个运行时记录配置的方法：

- WriteConfig：将当前Viper配置写入指定路径，如果保存路径不存在则报错，存在覆盖
- SafeWriteConfig：将当前Viper配置写入指定路径，如果保存路径不存在则报错，存在则不会覆盖
- WriteConfigAs：将当前Viper配置写入指定路径，覆盖指定文件（如果路径存在的话）
- SafeWriteConfigAs：将当前Viper配置写入指定路径，除指定文件外其他的都覆盖（如果路径存在的话）

```go
viper.WriteConfig() // 写入当前配置到'viper.AddConfigPath()' 和 'viper.SetConfigName'设定的路径
viper.SafeWriteConfig()
viper.WriteConfigAs("/path/to/my/.config")
viper.SafeWriteConfigAs("/path/to/my/.config") // 这里将报错，因为已经写入过了
viper.SafeWriteConfigAs("/path/to/my/.other_config")
```

#### 如何让配置实时生效

Viper支持应用程序在运行时实时读取配置文件的能力，只需要告诉Viper去watchConfig即可。或者直接自己去实现一个函数，每次更改配置文件时都运行。

示例：（该示例运行前请确保你已经设置了configPaths）

```go
viper.OnConfigChange(func(e fsnotify.Event) {
	fmt.Println("Config file changed:", e.Name)
})
viper.WatchConfig()
```

#### 自定义配置源

虽然Viper自带多种配置源，但是这也不妨碍我们自定义。

示例：

```go
viper.SetConfigType("yaml") // or viper.SetConfigType("YAML")

// 自定义案例
var yamlExample = []byte(`
Hacker: true
name: steve
hobbies:
- skateboarding
- snowboarding
- go
clothing:
  jacket: leather
  trousers: denim
age: 35
eyes : brown
beard: true
`)

viper.ReadConfig(bytes.NewBuffer(yamlExample))

viper.Get("name") // 这里将输出 "steve"
```

#### 从Viper中获取配置值

在Viper中有多个获取配置文件内容的方法，可根据值的类型进行选择：

- `Get(key string) : interface{}`
- `GetBool(key string) : bool`
- `GetFloat64(key string) : float64`
- `GetInt(key string) : int`
- `GetIntSlice(key string) : []int`
- `GetString(key string) : string`
- `GetStringMap(key string) : map[string]interface{}`
- `GetStringMapString(key string) : map[string]string`
- `GetStringSlice(key string) : []string`
- `GetTime(key string) : time.Time`
- `GetDuration(key string) : time.Duration`
- `IsSet(key string) : bool`
- `AllSettings() : map[string]interface{}`

注：所有GET方法在没有找到对应的配置参数时将返回0，判断对应的配置参数是否存在可用IsSet()函数

示例：

```go
viper.GetString("logfile") // 不区分大小写
if viper.GetBool("verbose") {
	fmt.Println("verbose enabled")
}
```

#### 访问嵌套类型的配置文件

Viper默认是支持访问嵌套类型的，例如一下JSON，如果要访问其中的某个被嵌套的Key可如此操作：

```go
{
    "host": {
        "address": "localhost",
        "port": 5799
    },
    "datastore": {
        "metric": {
            "host": "127.0.0.1",
            "port": 3099
        },
        "warehouse": {
            "host": "198.0.0.1",
            "port": 2112
        }
    }
}
```

```go
GetString("datastore.metric.host") // (返回 "127.0.0.1")
```

可以通过"."进行嵌套key的访问/获取。

如果你有个嵌套key是一个数组，那我们可以直接读取其下标进行访问：

```go
{
    "host": {
        "address": "localhost",
        "ports": [
            5799,
            6029
        ]
    },
    "datastore": {
        "metric": {
            "host": "127.0.0.1",
            "port": 3099
        },
        "warehouse": {
            "host": "198.0.0.1",
            "port": 2112
        }
    }
}
```

```go
GetInt("host.ports.1") // 返回 6029
```

还有一种极端情况，就是你某个key的名称中就带"."，那么有人就会疑惑会不会无法操作读取呀？放心，Viper已经想到这个问题了，如果有对应的路径则直接取，没有的话才会去嵌套取值：

示例：

```go
{
    "datastore.metric.host": "0.0.0.0",
    "host": {
        "address": "localhost",
        "port": 5799
    },
    "datastore": {
        "metric": {
            "host": "127.0.0.1",
            "port": 3099
        },
        "warehouse": {
            "host": "198.0.0.1",
            "port": 2112
        }
    }
}
```

```go
GetString("datastore.metric.host") // 返回 "0.0.0.0"
```

看，这里返回的是"0.0.0.0" 而不是“127.0.0.1”，我称之为精准匹配原则（我自己定义的哈哈哈哈哈）

#### 以String的形式返回所有配置内容

很多时候我们需要看某个应用程序的配置时是在服务器运行期间，这个时候我们并不是想把他的配置都写入文件中而仅仅是单纯的看一下，那么这个时候AllSettings()这个函数就排上用场了。

```go
import (
	yaml "gopkg.in/yaml.v2"
	// ...
)

func yamlStringSettings() string {
	c := viper.AllSettings()
	bs, err := yaml.Marshal(c)
	if err != nil {
		log.Fatalf("unable to marshal config to YAML: %v", err)
	}
	return string(bs)
}
```

AllSettings()会以String类型返回当前配置中的所有配置内容，

#### 多个Viper实例的使用

上面我们说过：

> Viper虽然支持多配置同时使用，但是一个Viper实例只能寻一个配置路径。

所有如果想支持多配置启用，那么你就多实现几个Viper的实例就可以了。

```go
x := viper.New()
y := viper.New()

x.SetDefault("ContentDir", "content")
y.SetDefault("ContentDir", "foobar")
```

OK，Just this ，See you next~

---

## <a id="6">GORM-Go语言中号称最友好的ORM</a>

ORM即Object-Relationl Mapping，就是对象关系映射。它的作用就是在对象和关系数据库中间做一个映射，这样我们在操作数据库的时候就不需要直接去和SQL打架。

其在Go圈子中非常火，功能覆盖范围也非常广，这节我们不做太深入的研究，先搞明白怎么用即可。

#### 安装

```go
go get -u gorm.io/gorm
```

如果上面这个你用不了就用下面这个

```go
go get github.com/jinzhu/gorm
```

#### 快速开始案例---Sqlite数据库链接

```go
package main
//导包
import (
  "gorm.io/gorm"
  "gorm.io/driver/sqlite"
)
//定义一个模型
type Product struct {
  gorm.Model
  Code  string
  Price uint
}

func main() {
  //根据配置文件链接名为test.db的数据库
  db, err := gorm.Open(sqlite.Open("test.db"), &gorm.Config{})
  if err != nil {
    panic("failed to connect database")
  }

  // 在数据库中创建对应的Product表
  db.AutoMigrate(&Product{})

  // 创建一条数据
  db.Create(&Product{Code: "D42", Price: 100})

  // 查询数据
  var product Product
  db.First(&product, 1) 
  db.First(&product, "code = ?", "D42") 

  // 更新数据
  db.Model(&product).Update("Price", 200)
  // 更新多条数据
  db.Model(&product).Updates(Product{Price: 200, Code: "F42"}) // non-zero fields
  db.Model(&product).Updates(map[string]interface{}{"Price": 200, "Code": "F42"})

  // 删除数据
  db.Delete(&product, 1)
}
```

#### 快速开始案例---MySQL数据库链接

```go
import (
  "gorm.io/driver/mysql"
  "gorm.io/gorm"
)

func main() {
  // refer https://github.com/go-sql-driver/mysql#dsn-data-source-name for details
  dsn := "user:pass@tcp(127.0.0.1:3306)/dbname?charset=utf8mb4&parseTime=True&loc=Local"
  db, err := gorm.Open(mysql.Open(dsn), &gorm.Config{})
}
```

GORM还为MySQL Driver提供了一些可以在初始化期间使用的高级配置，如下：

```go
db, err := gorm.Open(mysql.New(mysql.Config{
  DSN: "gorm:gorm@tcp(127.0.0.1:3306)/gorm?charset=utf8&parseTime=True&loc=Local", // 数据源
  DefaultStringSize: 256, // 字符串的默认大小
  DisableDatetimePrecision: true, // 在MySQL 5.6版本之前不支持日期时间精度，这里给禁用
  DontSupportRenameIndex: true, // 在MySQL 5.7之前不支持重命名索引
  DontSupportRenameColumn: true, // MySQL 8不支持重命名列
  SkipInitializeWithVersion: false, // 根据当前MySQL版本自动配置
}), &gorm.Config{})
```

#### 自定义Driver

在GORM中允许使用DriverName选项去自定义MySQL Driver，如下：

```go
import (
  _ "example.com/my_mysql_driver"
  "gorm.io/gorm"
)

db, err := gorm.Open(mysql.New(mysql.Config{
  DriverName: "my_mysql_driver",
  DSN: "gorm:gorm@tcp(localhost:9910)/gorm?charset=utf8&parseTime=True&loc=Local", // 数据源
}), &gorm.Config{})
```

GROM允许去初始化*gorm.DB 去持有一个现有的数据库链接，如下：

```go
import (
  "database/sql"
  "gorm.io/driver/mysql"
  "gorm.io/gorm"
)

sqlDB, err := sql.Open("mysql", "mydb_dsn")
gormDB, err := gorm.Open(mysql.New(mysql.Config{
  Conn: sqlDB,
}), &gorm.Config{})
```

除了以上举的这两个数据库外，其实还有PostgreSQL、SQLServer、Clickhouse、Pool 等，这些就自行去查阅吧。

#### 创建模型

模型就是采用Go的基本类型、指针/别名或者其他用户自定义类型等信息去实现Scanner和Valuer接口。

直接看示例：

```go
type User struct {
  ID           uint
  Name         string
  Email        *string
  Age          uint8
  Birthday     *time.Time
  MemberNumber sql.NullString
  ActivatedAt  sql.NullTime
  CreatedAt    time.Time
  UpdatedAt    time.Time
}
```

在GORM中有一个默认的约定，以模型创建的表默认表名就是结构体名称，默认字段就是结构体中的字段，默认的primary key就是ID，并且自带CreateAt和UpdateAt字段去记录创建和更新时间。如果GROM的这个默认约定不满足你的使用，那么你也可以抛弃这个约定去自行定义。

#### gorm.Model

这个在我们开源十年项目中就用过，且也给大家讲述过，它是GROM默认的结构体，你可以直接把它嵌入进自己的结构体中，然后你的结构体将包含它所自带的几个字段：ID，CreateAt，UpdateAt,DeletedAt

```go
type Model struct {
  ID        uint           `gorm:"primaryKey"`
  CreatedAt time.Time
  UpdatedAt time.Time
  DeletedAt gorm.DeletedAt `gorm:"index"`
}
```

#### 字段的权限等级

使用GROM去做增删查改的时候对所有字段是拥有所有权限的，其实GROM是允许我们通过Tag去修改字段的等级权限的，所以在正常的开发中我们可以去自定义字段的只读、只写、只允许创建、只允许更新或者忽略等权限。

注：这里需要注意的一点是，如果某个字段设置了Tag为忽略，那么在我们去创建这个表的时候也是会忽略这个字段的。

具体设置参考下表：

```go
type User struct {
  Name string `gorm:"<-:create"` // 允许读和创建
  Name string `gorm:"<-:update"` // 允许读和更新
  Name string `gorm:"<-"`        // 允许读写（创建和更新）
  Name string `gorm:"<-:false"`  // 允许读 ，不允许写
  Name string `gorm:"->"`        // 只读（除非有别的特殊配置不然就是禁用写）
  Name string `gorm:"->;<-:create"` // 允许读和创建
  Name string `gorm:"->:false;<-:create"` // 只是创建（禁用从数据库的读取权限）
  Name string `gorm:"-"`            // 在结构体读写时忽略此字段
  Name string `gorm:"-:all"`        // 在结构体读写、甚至是迁移表时忽略此字段
  Name string `gorm:"-:migration"`  // 在结构体迁移表时忽略该字段
}
```

#### 默认CreatAt/UpdateAt和默认时间格式的使用

在GROM中CreatAt和UpdateAt是默认的，且会在我们操作相关数据是自动记录并更新其时间内容。如果我们想自定义同类型的字段只需要加上autoCreateTime和autoUpdateTime的Tag即可。同时GROM默认的时间格式是time.Time,如果你想用秒或者其它类型去记录，只需要把time/Time更改为Int或者对应的其它类型即可。

示例：

```go
type User struct {
  CreatedAt time.Time // 创建时不指定具体指会默认设置为当前时间
  UpdatedAt int       // 在更新时设置为当前unix秒类型的值，创建时此值为0
  Updated   int64 `gorm:"autoUpdateTime:nano"` // 使用unix nano类型为更新时间
  Updated   int64 `gorm:"autoUpdateTime:milli"`// 使用 unix milli 类型为更新时间
  Created   int64 `gorm:"autoCreateTime"`      // 使用unix为创建时间
}
```

#### 嵌入式结构

我喜欢称之为集成式结构，客官们随意哈。对于此结构我们可以实现更多种类型和更复杂的结构，并且便于维护和读写。示例：

```go
type Author struct {
  Name  string
  Email string
}

type Blog struct {
  ID      int
  Author  Author `gorm:"embedded"`
  Upvotes int32
}
// 上面那种写法与下面的这种写法是一样的效果
type Blog struct {
  ID    int64
  Name  string
  Email string
  Upvotes  int32
}
```

同时可以使用embeddedPrefix这个标签为字段在数据库中添加前缀：

```go
type Blog struct {
  ID      int
  Author  Author `gorm:"embedded;embeddedPrefix:author_"`
  Upvotes int32
}
// equals
type Blog struct {
  ID          int64
  AuthorName  string
  AuthorEmail string
  Upvotes     int32
}
```

这么看的话就很方便了是吧。

在GROM中具体有哪些Tag，我这里就不去一一列举了，就像字典一样，你用到了再去查效果会好很多。

```go
column
//指定 db 列名

type
//列数据类型，推荐使用兼容性好的通用类型，例如：所有数据库都支持 bool、int、uint、float、string、time、bytes 并且可以和其他标签一起使用，例如：not null、size, autoIncrement… 像 varbinary(8) 这样指定数据库数据类型也是支持的。在使用指定数据库数据类型时，它需要是完整的数据库数据类型，如：MEDIUMINT UNSIGNED not NULL AUTO_INSTREMENT


size
//指定列大小，例如：size:256


primaryKey
//指定列为主键


unique
//指定列为唯一


default
//指定列的默认值


precision
//指定列的精度


scale
//指定列大小


not null
//指定列为 NOT NULL


autoIncrement
//指定列为自动增长


embedded
//嵌套字段


embeddedPrefix
//嵌入字段的列名前缀


autoCreateTime
//创建时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano/milli 来追踪纳秒、毫秒时间戳，例如：autoCreateTime:nano


autoUpdateTime
//创建 / 更新时追踪当前时间，对于 int 字段，它会追踪时间戳秒数，您可以使用 nano/milli 来追踪纳秒、毫秒时间戳，例如：autoUpdateTime:milli


index
//根据参数创建索引，多个字段使用相同的名称则创建复合索引，查看 索引 获取详情


uniqueIndex
//与 index 相同，但创建的是唯一索引


check
//创建检查约束，例如 check:age > 13，查看 约束 获取详情


<-
//设置字段写入的权限， <-:create 只创建、<-:update 只更新、<-:false 无写入权限、<- 创建和更新权限


->
//设置字段读的权限，->:false 无读权限

-
//忽略该字段，- 无读写权限
```

### 增删查改。

在学习GORM的时候，除了上面这些东西是需要我们理解之外，以下内容才是我们需要学的重点。

##### Create

```go
user := User{Name: "Jinzhu", Age: 18, Birthday: time.Now()}

result := db.Create(&user) // 将数据指针传给Create

user.ID             // 返回数据的ID prinary key 
result.Error        // 返回错误信息
result.RowsAffected // 返回插入的记录数
//创建一条记录并为指定字段赋值
db.Select("Name", "Age", "CreatedAt").Create(&user)//INSERT INTO `users` (`name`,`age`,`created_at`) VALUES ("jinzhu", 18, "2020-07-04 11:05:21.775")
//创建一条记录并忽略掉给省略字段传值
db.Omit("Name", "Age", "CreatedAt").Create(&user)
// INSERT INTO `users` (`birthday`,`updated_at`) VALUES ("2020-01-01 00:00:00.000", "2020-07-04 11:05:21.775")

//批量插入
var users = []User{{Name: "jinzhu1"}, {Name: "jinzhu2"}, {Name: "jinzhu3"}}
db.Create(&users)

for _, user := range users {
  user.ID // 1,2,3
}
//也可以使用CreateInBatches指定批量的范围
var users = []User{{Name: "jinzhu_1"}, ...., {Name: "jinzhu_10000"}}

// batch size 100
db.CreateInBatches(users, 100)

```

##### 检索单个对象

```go
// 获取排在第一的值（以prinary key排序）
db.First(&user)
// SELECT * FROM users ORDER BY id LIMIT 1;

// 随便获取一个值
db.Take(&user)
// SELECT * FROM users LIMIT 1;

// 获取排在最后一个的值（以prinary key排序）
db.Last(&user)
// SELECT * FROM users ORDER BY id DESC LIMIT 1;

result := db.First(&user)
result.RowsAffected // 返回一共查到了多少条记录
result.Error        // 返回错误信息

// 检查是否存在错误 ErrRecordNotFound
errors.Is(result.Error, gorm.ErrRecordNotFound)

```

First和Last这两个只有在目标结构的指针做参数时才起作用，此外，如果这个模型没有primary key那返回的顺序就是按照第一个字段排序的结果去取值。

按照指定主键去检索

```go
db.First(&user, 10)
// SELECT * FROM users WHERE id = 10;

db.First(&user, "10")
// SELECT * FROM users WHERE id = 10;

db.Find(&users, []int{1,2,3})
// SELECT * FROM users WHERE id IN (1,2,3);
//如果主键是字符串（例如，像 uuid），则查询如下：
db.First(&user, "id = ?", "1b74413f-f3b8-409f-ac47-e8c062e3472a")
// SELECT * FROM users WHERE id = "1b74413f-f3b8-409f-ac47-e8c062e3472a";

```

注：在主键是字符串时，请谨防SQL注入安全事故。

```go
//检索所有对象
// 获取所有记录
result := db.Find(&users)
// SELECT * FROM users;

```

条件查询

```go
// 获取第一条匹配的记录
db.Where("name = ?", "jinzhu").First(&user)
// SELECT * FROM users WHERE name = 'jinzhu' ORDER BY id LIMIT 1;

// 获取所有匹配的记录
db.Where("name <> ?", "jinzhu").Find(&users)
// SELECT * FROM users WHERE name <> 'jinzhu';


//以下的IN LIKE AND Time等就跟我们学的SQL语句中的用法是一样的了
// IN
db.Where("name IN ?", []string{"jinzhu", "jinzhu 2"}).Find(&users)
// SELECT * FROM users WHERE name IN ('jinzhu','jinzhu 2');

// LIKE
db.Where("name LIKE ?", "%jin%").Find(&users)
// SELECT * FROM users WHERE name LIKE '%jin%';

// AND
db.Where("name = ? AND age >= ?", "jinzhu", "22").Find(&users)
// SELECT * FROM users WHERE name = 'jinzhu' AND age >= 22;

// Time
db.Where("updated_at > ?", lastWeek).Find(&users)
// SELECT * FROM users WHERE updated_at > '2000-01-01 00:00:00';

// BETWEEN
db.Where("created_at BETWEEN ? AND ?", lastWeek, today).Find(&users)
// SELECT * FROM users WHERE created_at BETWEEN '2000-01-01 00:00:00' AND '2000-01-08 00:00:00';

```

暂时查询就说这么多吧，够现阶段用了。后面还有排序、限制条件、分组、Join等等跟我们之前语言中遇到的基本是一致的。

##### Update

```go
//Save将会把所有字段都存储
db.First(&user)

user.Name = "jinzhu 2"
user.Age = 100
db.Save(&user)
// UPDATE users SET name='jinzhu 2', age=100, birthday='2016-01-01', updated_at = '2013-11-17 21:34:10' WHERE id=111;


//更新单列
// 按条件更新
db.Model(&User{}).Where("active = ?", true).Update("name", "hello")
// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE active=true;

// 更新指定条件的记录
db.Model(&user).Update("name", "hello")
// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111;

//使用条件+模型值更新
db.Model(&user).Where("active = ?", true).Update("name", "hello")
// UPDATE users SET name='hello', updated_at='2013-11-17 21:34:10' WHERE id=111 AND active=true;


//更新多列
// 使用结构模型更新属性，但是只会更新非0的字段
db.Model(&user).Updates(User{Name: "hello", Age: 18, Active: false})
// UPDATE users SET name='hello', age=18, updated_at = '2013-11-17 21:34:10' WHERE id = 111;

// 使用map更新属性
db.Model(&user).Updates(map[string]interface{}{"name": "hello", "age": 18, "active": false})
// UPDATE users SET name='hello', age=18, active=false, updated_at='2013-11-17 21:34:10' WHERE id=111;


//更新指定的属性

db.Model(&user).Select("name").Updates(map[string]interface{}{"name": "hello", "age": 18, "active": false})
// UPDATE users SET name='hello' WHERE id=111;

db.Model(&user).Omit("name").Updates(map[string]interface{}{"name": "hello", "age": 18, "active": false})
// UPDATE users SET age=18, active=false, updated_at='2013-11-17 21:34:10' WHERE id=111;

// 注意肯定是非0值
db.Model(&user).Select("Name", "Age").Updates(User{Name: "new_name", Age: 0})
// UPDATE users SET name='new_name', age=0 WHERE id=111;

// 选择所有字段包括非0
db.Model(&user).Select("*").Update(User{Name: "jinzhu", Role: "admin", Age: 0})

// 选择所有字段包括非0 但是忽略“Role”
db.Model(&user).Select("*").Omit("Role").Update(User{Name: "jinzhu", Role: "admin", Age: 0})
```

##### Delete

```go
//删除单条记录
db.Delete(&email)
// DELETE from emails where id = 10;

// 按条件删除
db.Where("name = ?", "jinzhu").Delete(&email)
// DELETE from emails where id = 10 AND name = "jinzhu";

//按primary key去删除
db.Delete(&User{}, 10)
// DELETE FROM users WHERE id = 10;

db.Delete(&User{}, "10")
// DELETE FROM users WHERE id = 10;

db.Delete(&users, []int{1,2,3})
// DELETE FROM users WHERE id IN (1,2,3);

//批量删除
db.Where("email LIKE ?", "%jinzhu%").Delete(&Email{})
// DELETE from emails where email LIKE "%jinzhu%";

db.Delete(&Email{}, "email LIKE ?", "%jinzhu%")
// DELETE from emails where email LIKE "%jinzhu%";

```

好了 ，就先分享这么多吧。其实Gorm的内容非常多，但是其中的很多内容都是百变不离其宗。用到了再来查就是了，目前这些对于我们现阶段的项目来说够用就行。

OK .Just this,See you next...



##  <a id="7">开源十年一周总结</a>

从这个想法出现到实施已经一周时间了，这一周收获还是挺大的，下面我就从以下几个方面总结一下吧。

#### 时间管理



因为我目前还在上班，程序员的上班你应该懂得，不加班那是不可能的，所以我在开源十年这个项目中能投入的时间就十分紧张。但是既然自己要坚持那就会想方设法的去挤时间，时间就像海绵里面的水---挤挤总是有的。

要么就是早上早点起，利用上班之前的这一点时间来思考项目。要么就是晚上睡前的那一块时间，利用这点时间来完成早上思考的东西。

周末的话，视情况而定吧。像我这种有家庭的周末时间基本不会属于自己的，而且我也不建议大家周末时间过多的去做一些私事。毕竟成家后的家庭不是你一个人了，多分一点时间给老婆孩子或者父母朋友。

#### 心理上感受

这一周应该是我三十而立以来最充实的一周，在这一周的时间里我没有再焦虑、彷徨、恐惧。究其原因就是我根本就没有时间去焦虑，每一分每一秒都被安排的满满的。所以我建议那些还在迷茫和焦虑的小伙伴向我学习，哈哈哈。

之前在我迷茫的那一段时间里，工作上工作的不够认真，学习上学习的无法专主，陪伴家人上陪伴的不够踏实。总之就是干啥啥不行，玩也玩得不开心。因为人在有心事的状态下会直接影响到你的生活状态，每天愁眉苦脸的人运气也确实好不到哪里去。

这一周所说在项目上并没有什么进展，但是心理上或者说是自己的价值观、世界观改变的却挺大的。我想这就是目标带给我的动力吧。

#### 人脉圈子

所谓人脉，并不是说非得是有利用价值的才算人脉。我认为只要有共同爱好就行，不图对方什么利益，就单纯的想就某件事交流而已。这样的交流才是最真、最有价值、最直接的，如果你带着某些目的或者利益关系去交流往往得到的结果并不是真实的。

这一周，陆陆续续加我好友的人有十来个了吧，基本上每个人我都简单沟通过。有想跟我一起做项目的、有想学习的、有想借鉴我这种方式摆脱人生迷茫的，也有的就是单纯的加个好友想看看我到底能坚持多长时间的。

不管各位是怀着什么目的来的，我觉得至少我们都会有一个共鸣点，Do It .

#### 项目进度计划

我的计划就是没有计划，本来就是一个兴趣爱好的坚持，我不会逼迫自己去赶进度。就像刚过去的这周一样，真实进度几乎没有，但是我收获比进度赶上来的收获更大。

人生很多时候就是这样，走得太快错过了很多美好的风景。我们应该慢慢走，欣赏沿途的美丽和深入了解遇到的每一处知识点。

#### 录制视频

有人劝我说把这种项目实践录制成视频也许更受欢迎，may be.但是说实话，这个开源十年项目的目的有一部分是分享知识，但更多的是想传递坚持的理念。

并且我也不认为自己是一个好的编程老师，所以录制视频的事情暂时搁置吧。

#### 下周计划

这周零零散散的把第一阶段开发中遇到的知识点都去啃了一下，下周的话继续项目的进度，把BLOG的几项功能接口先完善了吧。

然后看看路上还能遇到什么美景，遇到了我们就继续欣赏。没什么美景的话我们就继续前行。





## <a id="8">JWT-Go 实现登录Token发放和验证</a>

第一阶段的知识点啃的差不多了，这周继续往下进行。因为我们目前要实现的是一个BLOG系统，那么我们肯定要考虑安全问题。不能说任何一个人上来就能随便发布博文，那我们这个blog系统最后就广告、垃圾横行了。所以我们只允许注册了的用户使用我们的系统，没有经过注册的坚决拒绝其使用。

在系统中怎么判断一个人是否是我们的用户应该怎么做呢？那就是用户拿自己的账号和密码给系统进行验证，系统看看他是不是已经注册的用户，如果账号和密码都能匹配上就允许访问，如果匹配不上就拒绝其访问。

但是在实际项目中，我们不可能在用户每次访问的时候都跟用户去要账号和密码，就算你这么去要也不安全呀。所以这个时候我们就需要采取一种加密手段。通过这种加密手段去处理用户的账号和密码，然后在用户每次访问我们的时候带上这一穿加密字符串就行了。

这样既解决了认证的问题还解决了安全的问题，这就是Token，在Go语言中有一个库已经解决了我们这个问题他就是：jwt-go.

安装go-jwt：go get -u github.com/dgrijalva/jwt-go

在开始写代码之前我们先回顾一下流程：

1）用户注册账号设置密码，成功后我们把其信息存入我们的库中。

2）用户登录，服务端先校验用户传入的账号和密码，准确无误后生成一个token给用户。

3）用户访问需要权限的接口时携带这个token即可。

下面开始编程，一探jwt-go的用法。

#### 1、指定加密秘钥

```go
var jwtKey = []byte("kai_yuan_shi_nian")
```

这就相当于是一把钥匙，自己保存好，造锁和开锁都是依托这把钥匙进行的。

#### 2、创建Claims结构体

```go
type Claims struct {
	UserId uint
	jwt.StandardClaims
}
```

这个结构体就是用来保存信息的，需要内嵌jwt.StandardClaims，这些信息会被保存在我们生成好的token当中。

#### 3、生成token

```go
func ReleaseToken(user model.User) (string,error){
	expirationTime := time.Now().Add(7 * 24 * time.Hour)
	claims := &Claims{
		UserId : user.ID,
		StandardClaims: jwt.StandardClaims{
			ExpiresAt: expirationTime.Unix(),//设置这个token的有效期
			IssuedAt: time.Now().Unix(),//发放时间
			Issuer: "kaiyuanshinian.tech",//发行方
			Subject: "user token",//主题
		},
	}
	//使用指定的签名方式创建签名对象
	token := jwt.NewWithClaims(jwt.SigningMethodHS256,claims)
  //使用上面指定的钥匙(secret)签名并获取完整的签名后的字符串
	tokenString,err := token.SignedString(jwtKey)

	if err != nil{
		return "",err
	}

	return tokenString,nil
}
```

在上面这段代码中我们分别设置了有效期和发布方信息。除了上面代码中用到的有效期、签发时间、签发人信息外，还有生效时间(NotBefore)、受众(Audience)、编号(JWTID)等等信息看需求你可以自己添加。

#### 4、解析token

```go
func ParseToken(tokenString string)(*jwt.Token,*Claims,error){
	claims := &Claims{}
	//用于解析鉴权声明
	token,err := jwt.ParseWithClaims(tokenString,claims,func(token *jwt.Token)(i interface{},err error){
		return jwtKey,nil
	})

	return token,claims,err
}
```

解析token就是在用户访问我们的时候，我们系统去解析他所携带的token，去验证它是否是我们正确的用户。我们可以直接根据token获取到它所携带的用户信息（上面的结构体）

#### 5、编写路由

上面完成后，我们开始写我们的业务功能，前面我们已经实现注册功能了，这里就不多说了。首先我们去实现登录功能，直接上代码分析：

```go
r.POST("/v1/account/login", controller.Login)
```

先写路由，指向Login去接收处理，那么我们再看看系统收到该接口访问时的处理。

其处理顺序是：

1）先获取用户访问接口是携带的参数

2）拿这些参数去校验我们的库是否准确（手机号、密码等信息）

3）准确的话发放token并返回登录成功

```go
//登录
func Login(ctx *gin.Context){
	DB := common.GetDB()
	//获取参数
	mobile := ctx.PostForm("mobile")
	password := ctx.PostForm("password")
	//数据验证
	if len(mobile) != 11 {
		response.Response(ctx,http.StatusUnprocessableEntity,422,nil,"手机号必须为11位")
		return
	}
	if len(password) < 6 {
		response.Response(ctx,http.StatusUnprocessableEntity,422,nil,"密码不能少于6位")
		return
	}
	//判断手机号是否存在
	var user model.User
	DB.Where("mobile = ?",mobile).First(&user)
	if user.ID == 0 {
		response.Response(ctx,http.StatusUnprocessableEntity,422,nil,"用户不存在")
		return
	}
	//判断密码是否正确
	if err := bcrypt.CompareHashAndPassword([]byte(user.Password),[]byte(password));err != nil{
		response.Response(ctx,http.StatusUnprocessableEntity,400,nil,"密码错误")
		return
	}
	//发放token
	token,err := common.ReleaseToken(user)
	if err != nil{
		response.Response(ctx,http.StatusUnprocessableEntity,500,nil,"系统异常")
		log.Printf("token generate error : %v",err)
		return
	}
	//返回结果
	fmt.Println(token)
	response.Success(ctx,gin.H{"token":token},"登录成功")
}
```

在上面的代码中我们就用到了前面实现的token发放模块（ReleaseToken）。

到此，登录功能就已经实现了，那么这个token怎么使用呢？我们继续往下去实现一个可以获取用户信息的接口。

#### 6、token验证及使用

直接先上路由

```go
r.GET("/v1/account/info", common.AuthMiddleware(),controller.Info)
```

各位发现没有，这次注册路由的时候明显与前面两次不同了，多了一个common.AuthMiddleware()。它就是验证token必不可少的一环。

其AuthMiddleware()函数的主要内容如下：

```go 
func AuthMiddleware() gin.HandlerFunc{
	return func(ctx *gin.Context) {
		//先从header中获取token
		tokenString := ctx.GetHeader("Authorization")

		//然后再去验证token不为空和它的类型
		if tokenString == "" || !strings.HasPrefix(tokenString,"Bearer"){
			ctx.JSON(http.StatusUnauthorized,gin.H{"code":401,"msg":"权限不足"})
			ctx.Abort()
			return
		}
		//抛去前面的7个字节不要（其主要内容就是一个bearer类型声明）
    //token示例： ~~Bearer ~~ eyJhbGciOiJIUzI1NiIsInR...Ndafg，前面7位正好是：Bearer <-这里还有一个空格哦

		tokenString = tokenString[7:]

		token,claims,err := ParseToken(tokenString)

		if err != nil || !token.Valid{
			ctx.JSON(http.StatusUnauthorized,gin.H{"code":401,"msg":"权限不足"})
			ctx.Abort()
			return
		}
		//通过验证后获取claims中的userID
		userId := claims.UserId
		DB := GetDB()
		var user model.User
		DB.First(&user,userId)

		//检查用户是否存在
		if user.ID == 0{
			ctx.JSON(http.StatusUnauthorized,gin.H{"code":401,"msg":"用户不存在"})
			ctx.Abort()
			return
		}

		//如果用户存在 将user信息存入上下文
		ctx.Set("user",user)
		ctx.Next()
	}
}

```

这里主要做了几件事情：

1）校验token的有效性，有效go on ,无效 stop it.

2）校验完毕后取出token中的claims进行解析，根据上面我们的结构体可知，我们可以得到用户的userID。

3）拿该userID去我们的库中查询是否存在，存在go on ,不存在 stop it.

完事。

后面的就不用多说了，看下我们调用v1/account/info接口给我们返回了什么数据吧。

```json
{
    "code": 200,
    "data": {
        "user": {
            "name": "张三",
            "telephone": "13523422342"
        }
    },
    "msg": "请求成功"
}
```

目前我们仅仅用到了jwt-go的核心部分，其还有很多可扩展功能有待我们去开发学习，本节就先到这里吧。

ok just it ,see you next...

